var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#API:-System","page":"API","title":"System","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"System","category":"page"},{"location":"api/#CollectiveSpins.System","page":"API","title":"CollectiveSpins.System","text":"Abstract base class for all systems defined in this library.\n\nCurrently there are the following concrete systems:\n\nSpin\nSpinCollection\nCavityMode\nCavitySpinCollection\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Spin","category":"page"},{"location":"api/#CollectiveSpins.Spin","page":"API","title":"CollectiveSpins.Spin","text":"A class representing a single spin.\n\nA spin is defined by its position and its detuning to a main frequency.\n\nArguments\n\nposition: A vector defining a point in R3.\ndelta: Detuning.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"SpinCollection","category":"page"},{"location":"api/#CollectiveSpins.SpinCollection","page":"API","title":"CollectiveSpins.SpinCollection","text":"A class representing a system consisting of many spins.\n\nArguments\n\nspins: Vector of spins.\npolarizations: Unit vectors defining the directions of the spins.\ngammas: Decay rates.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CavityMode","category":"page"},{"location":"api/#CollectiveSpins.CavityMode","page":"API","title":"CollectiveSpins.CavityMode","text":"A class representing a single mode in a cavity.\n\nArguments\n\ncutoff: Number of included Fock states.\ndelta=0 Detuning.\neta=0: Pump strength.\nkappa=0: Decay rate.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CavitySpinCollection","category":"page"},{"location":"api/#CollectiveSpins.CavitySpinCollection","page":"API","title":"CollectiveSpins.CavitySpinCollection","text":"A class representing a cavity coupled to many spins.\n\nArguments\n\ncavity: A CavityMode.\nspincollection: A SpinCollection.\ng: A vector defing the coupling strengths between the i-th spin and   the cavity mode. Alternatively a single number can be given for   identical coupling for all spins.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Geometry","page":"API","title":"Geometry","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"geometry.chain","category":"page"},{"location":"api/#CollectiveSpins.geometry.chain","page":"API","title":"CollectiveSpins.geometry.chain","text":"geometry.chain(a, N)\n\nPositions of spins on a chain in x-direction.\n\nThe chain starts at the origin and continues into positive x-direction.\n\nArguments\n\na: Spin-spin distance.\nN: Number of spins\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.triangle","category":"page"},{"location":"api/#CollectiveSpins.geometry.triangle","page":"API","title":"CollectiveSpins.geometry.triangle","text":"geometry.triangle(a)\n\nPositions of spins on a equilateral triangle in the xy-plane with edge length a.\n\nThe positions are: (0,0,0), (a,0,0), (a/2, h, 0)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.rectangle","category":"page"},{"location":"api/#CollectiveSpins.geometry.rectangle","page":"API","title":"CollectiveSpins.geometry.rectangle","text":"geometry.rectangle(a, b; Nx=2, Ny=2)\n\nPositions of spins on a rectangular lattice in the xy-plane.\n\nThe lattice starts at the origin and continues into positive x and y direction.\n\nArguments\n\na: Spin-spin distance in x-direction.\nb: Spin-spin distance in y-direction.\nNx=2: Number of spins into x direction.\nNy=2: Number of spins into y direction.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.square","category":"page"},{"location":"api/#CollectiveSpins.geometry.square","page":"API","title":"CollectiveSpins.geometry.square","text":"geometry.square(a; Nx=2, Ny=2)\n\nPositions of spins on a square lattice in the xy-plane with distance a.\n\nThe lattice starts at the origin and continues into positive x and y direction.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.hexagonal","category":"page"},{"location":"api/#CollectiveSpins.geometry.hexagonal","page":"API","title":"CollectiveSpins.geometry.hexagonal","text":"geometry.hexagonal(a; Nr=1)\n\nPositions of spins on a hexagonal lattice in the xy-plane.\n\nThe hexagonal lattice consists of Nr rings.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.box","category":"page"},{"location":"api/#CollectiveSpins.geometry.box","page":"API","title":"CollectiveSpins.geometry.box","text":"geometry.box(a, b, c; Nx=2, Ny=2, Nz=2)\n\nPositions of spins on a orthorhombic lattice.\n\nThe lattice starts at the origin and continues into positive x, y and z direction.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.cube","category":"page"},{"location":"api/#CollectiveSpins.geometry.cube","page":"API","title":"CollectiveSpins.geometry.cube","text":"geometry.cube(a; Nx=2, Ny=2, Nz=2)\n\nPositions of spins on a cubic lattice with edge length a.\n\nThe lattice starts at the origin and continues into positive x, y and z direction.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.ring","category":"page"},{"location":"api/#CollectiveSpins.geometry.ring","page":"API","title":"CollectiveSpins.geometry.ring","text":"geometry.ring(a, N; distance = false)\n\nRing of N particles with radius a. If distance is set to true, then a gives the distance between particles and the radius is determined accordingly.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.lhc1","category":"page"},{"location":"api/#CollectiveSpins.geometry.lhc1","page":"API","title":"CollectiveSpins.geometry.lhc1","text":"geometry.lhc1()\n\nGeometry of the LHC-I light harvesting complex in the xy-plane centered around `z=0` with a mean interatomic distance of `1.0`. Positions `1` to `32` constitute the outer ring, while the inner ring comprises positions `33` to `38`.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.lhc1_p","category":"page"},{"location":"api/#CollectiveSpins.geometry.lhc1_p","page":"API","title":"CollectiveSpins.geometry.lhc1_p","text":"geometry.lhc1_p()\n\nNormalized polarization vectors in an LHC-I light harvesting complex. Entries `1` to `32` pertain to the outer ring, while entries `33` to `38` give the inner ring's dipole orientations.\n\nNote: This function does not return a geometry, butrather te polarizations of dipoles in the LHC-I complex.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"geometry.excitation_phases","category":"page"},{"location":"api/#CollectiveSpins.geometry.excitation_phases","page":"API","title":"CollectiveSpins.geometry.excitation_phases","text":"geometry.excitation_phases(k, pos)\n\nCalculate the excitation phases created in a geometry by an incident plane wave with wave vector k.\n\nArguments:\n* `k`: Wave vector of the incident plane wave.\n* `pos`: List of atomic positions.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Dipole-Dipole-Interaction","page":"API","title":"Dipole-Dipole Interaction","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.Omega","category":"page"},{"location":"api/#CollectiveSpins.interaction.Omega","page":"API","title":"CollectiveSpins.interaction.Omega","text":"interaction.Omega(ri::Vector, rj::Vector, µi::Vector, µj::Vector, γi::Real=1, γj::Real=1)\n\nArguments:\n\nri: Position of first spin\nrj: Position of second spin\nµi: Dipole orientation of first spin.\nµj: Dipole orientation of second spin.\nγi: Decay rate of first spin.\nγj: Decay rate of second spin.\n\nNote that the dipole moments μi and μj are normalized internally. To account for dipole moments with different lengths you need to scale the decay rates γi and γj, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.Gamma","category":"page"},{"location":"api/#CollectiveSpins.interaction.Gamma","page":"API","title":"CollectiveSpins.interaction.Gamma","text":"interaction.Gamma(ri::Vector, rj::Vector, µi::Vector, µj::Vector, γi::Real=1, γj::Real=1)\n\nArguments:\n\nri: Position of first spin\nrj: Position of second spin\nµi: Dipole orientation of first spin.\nµj: Dipole orientation of second spin.\nγi: Decay rate of first spin.\nγj: Decay rate of second spin.\n\nNote that the dipole moments μi and μj are normalized internally. To account for dipole moments with different lengths you need to scale the decay rates γi and γj, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.GammaMatrix","category":"page"},{"location":"api/#CollectiveSpins.interaction.GammaMatrix","page":"API","title":"CollectiveSpins.interaction.GammaMatrix","text":"interaction.GammaMatrix(S::SpinCollection)\n\nMatrix of the collective decay rate for a given SpinCollection.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.OmegaMatrix","category":"page"},{"location":"api/#CollectiveSpins.interaction.OmegaMatrix","page":"API","title":"CollectiveSpins.interaction.OmegaMatrix","text":"interaction.OmegaMatrix(S::SpinCollection)\n\nMatrix of the dipole-dipole interaction for a given SpinCollection.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.interaction.GreenTensor","category":"page"},{"location":"api/#CollectiveSpins.interaction.GreenTensor","page":"API","title":"CollectiveSpins.interaction.GreenTensor","text":"GreenTensor(r::Vector, k::Number=2π)\n\nCalculate the Green's Tensor at position r for wave number k defined by\n\nG = e^ikrBigleft(frac1kr + fraci(kr)^2 - frac1(kr)^3right)*I -\n    textbfrtextbfr^Tleft(frac1kr + frac3i(kr)^2 - frac3(kr)^3right)Big\n\nChoosing k=2π corresponds to the position r being given in units of the wavelength associated with the dipole transition.\n\nReturns a 3×3 complex Matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Effective-Interactions","page":"API","title":"Effective Interactions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.triangle_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.triangle_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.triangle_orthogonal","text":"effective_interaction.triangle_orthogonal(a)\n\nEffective Omega and Gamma for a equilateral triangle with edge length a.\n\nThe polarization axis is orthogonal to the triangle plane.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.square_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.square_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.square_orthogonal","text":"effective_interaction.square_orthogonal(a)\n\nEffective Omega and Gamma for a square with edge length a.\n\nThe polarization axis is orthogonal to the square plane.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.rectangle_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.rectangle_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.rectangle_orthogonal","text":"effective_interaction.rectangle_orthogonal(a, b)\n\nEffective Omega and Gamma for a rectangle with edge lengths a and b.\n\nThe polarization axis is orthogonal to the rectangle plane.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.cube_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.cube_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.cube_orthogonal","text":"effective_interaction.cube_orthogonal(a)\n\nEffective Omega and Gamma for a cube with edge length a\n\nThe polarization axis is orthogonal to the xy faces.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.box_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.box_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.box_orthogonal","text":"effective_interaction.box_orthogonal(a, b, c)\n\nEffective Omega and Gamma for a box with edge lengths a, b and c.\n\nThe polarization axis is orthogonal to the top face.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.chain","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.chain","page":"API","title":"CollectiveSpins.effective_interaction.chain","text":"effective_interaction.chain(a, Θ, N)\n\nEffective Omega and Gamma for an infinite chain.\n\nThe calculation is done by adding N spins left and N spins right of a central spin.\n\nArguments\n\na: Spin-spin distance.\nθ: Angle between polarization axis and spin chain.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.chain_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.chain_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.chain_orthogonal","text":"effective_interaction.chain_orthogonal(a, N)\n\nEffective Omega and Gamma for an infinite chain with orthogonal polarization axis.\n\nThe calculation is done by adding N spins left and N spins right of a central spin.\n\nArguments\n\na: Spin-spin distance.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.squarelattice_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.squarelattice_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.squarelattice_orthogonal","text":"effective_interaction.squarelattice_orthogonal(a, N)\n\nEffective Omega and Gamma for a infinite square lattice.\n\nThe polarization axis is orthogonal to the square lattice plane and the calculation is done by creating a (2N+1)*(2N+1) square lattice and calculate the combined interaction for the central spin.\n\nArguments\n\na: Spin-spin distance.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.hexagonallattice_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.hexagonallattice_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.hexagonallattice_orthogonal","text":"effective_interaction.hexagonallattice_orthogonal(a, N)\n\nEffective Omega and Gamma for a infinite hexagonal lattice.\n\nThe polarization axis is orthogonal to the square lattice plane and the calculation is done by creating hexagonal lattice consisting of N rings and calculate the combined interaction for the central spin.\n\nArguments\n\na: Spin-spin distance.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.cubiclattice_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.cubiclattice_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.cubiclattice_orthogonal","text":"effective_interaction.cubiclattice_orthogonal(a, N)\n\nEffective Omega and Gamma for a infinite cubic lattice.\n\nThe polarization axis is orthogonal to the top face of a unit cell and the calculation is done by creating a (2N+1)(2N+1)(2N+1) cubic lattice and calculate the combined interaction for the central spin.\n\nArguments\n\na: Spin-spin distance.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.tetragonallattice_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.tetragonallattice_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.tetragonallattice_orthogonal","text":"effective_interaction.tetragonallattice_orthogonal(a, b, N)\n\nEffective Omega and Gamma for a infinite tetragonal lattice.\n\nThe polarization axis is orthogonal to the top face of a unit cell and the calculation is done by creating a (2N+1)(2N+1)(2N+1) tetragonal lattice and calculate the combined interaction for the central spin.\n\nArguments\n\na: Spin-spin distance for bottom side square.\nb: Height of the unit cell.\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction.hexagonallattice3d_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction.hexagonallattice3d_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction.hexagonallattice3d_orthogonal","text":"effective_interaction.hexagonallattice3d_orthogonal(a, b, N)\n\nEffective Omega and Gamma for a infinite 3D hexagonal lattice.\n\nThe lattice consists of stacked planes of hexagonal lattices where the the polarization axis is orthogonal to the planes. The calculation is done by creating hexagonal lattices with N rings, stacking 2N+1 lattices of this kind above each other and calculating the combined interaction for the central spin.\n\nArguments\n\na: Spin-spin distance for hexagons.\nb: Distance between planes of hexagonal lattices\nN: Number of included spins.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Rotetated-effective-interactions","page":"API","title":"Rotated effective interactions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction_rotated.square_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction_rotated.square_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction_rotated.square_orthogonal","text":"effective_interaction_rotated.square_orthogonal(a, Nδ)\n\nEffective Omega and Gamma for a square.\n\nThe polarization axis is orthogonal to the square plane.\n\nArguments\n\na: Edge length.\nNδ: Phase shift (Number of atoms in 2π).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction_rotated.cube_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction_rotated.cube_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction_rotated.cube_orthogonal","text":"effective_interaction_rotated.cube_orthogonal(a, dϕ)\n\nEffective Omega and Gamma for a cube.\n\nThe polarization axis is orthogonal to the xy faces.\n\nArguments\n\na: edge length.\ndϕ: Phase shift.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.effective_interaction_rotated.chain_orthogonal","category":"page"},{"location":"api/#CollectiveSpins.effective_interaction_rotated.chain_orthogonal","page":"API","title":"CollectiveSpins.effective_interaction_rotated.chain_orthogonal","text":"effective_interaction_rotated.chain_orthogonal(a, N, dϕ)\n\nEffective Omega and Gamma for an infinite chain.\n\nThe polarization axis is orthogonal to the chain and the calculation is done by adding N spins left and N spins right of a central spin.\n\nArguments\n\na: Spin-spin distance.\nN: Number of included spins.\ndϕ: Phase shift between neighboring spins.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/#API:-Methods-quantum","page":"API","title":"Quantum","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.basis","category":"page"},{"location":"api/#CollectiveSpins.quantum.basis","page":"API","title":"CollectiveSpins.quantum.basis","text":"quantum.basis(x)\n\nGet basis of the given System.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.blochstate","category":"page"},{"location":"api/#CollectiveSpins.quantum.blochstate","page":"API","title":"CollectiveSpins.quantum.blochstate","text":"quantum.blochstate(phi, theta[, N=1])\n\nProduct state of N single spin Bloch states.\n\nAll spins have the same azimuthal angle phi and polar angle theta.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.dim","category":"page"},{"location":"api/#CollectiveSpins.quantum.dim","page":"API","title":"CollectiveSpins.quantum.dim","text":"quantum.dim(state)\n\nNumber of spins described by this state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.Hamiltonian","category":"page"},{"location":"api/#CollectiveSpins.quantum.Hamiltonian","page":"API","title":"CollectiveSpins.quantum.Hamiltonian","text":"quantum.Hamiltonian(S)\n\nHamiltonian of the given System.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.JumpOperators","category":"page"},{"location":"api/#CollectiveSpins.quantum.JumpOperators","page":"API","title":"CollectiveSpins.quantum.JumpOperators","text":"quantum.JumpOperators(S)\n\nJump operators of the given system.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.JumpOperators_diagonal","category":"page"},{"location":"api/#CollectiveSpins.quantum.JumpOperators_diagonal","page":"API","title":"CollectiveSpins.quantum.JumpOperators_diagonal","text":"quantum.JumpOperators_diagonal(S)\n\nJump operators of the given system. (diagonalized)\n\nDiagonalized means that the Gamma matrix is diagonalized and the jump operators are changed accordingly.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.timeevolution_diagonal","category":"page"},{"location":"api/#CollectiveSpins.quantum.timeevolution_diagonal","page":"API","title":"CollectiveSpins.quantum.timeevolution_diagonal","text":"quantum.timeevolution_diagonal(T, S, state0[; fout])\n\nMaster equation time evolution. (diagonalized)\n\nDiagonalized means that the Gamma matrix is diagonalized and the jump operators are changed accordingly.\n\nArguments\n\nT: Points of time for which output will be generated.\nS: System\nρ₀: Initial density operator.\nfout (optional): Function with signature fout(t, state) that is called   whenever output should be generated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.timeevolution","category":"page"},{"location":"api/#CollectiveSpins.quantum.timeevolution","page":"API","title":"CollectiveSpins.quantum.timeevolution","text":"quantum.timeevolution(T, S, state0[; fout])\n\nMaster equation time evolution.\n\nDiagonalized means that the Gamma matrix is diagonalized and the jump operators are changed accordingly.\n\nArguments\n\nT: Points of time for which output will be generated.\nS: System\nρ₀: Initial density operator.\nfout (optional): Function with signature fout(t, state) that is called   whenever output should be generated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.rotate","category":"page"},{"location":"api/#CollectiveSpins.quantum.rotate","page":"API","title":"CollectiveSpins.quantum.rotate","text":"meanfield.rotate(axis, angles, state)\n\nRotations on the Bloch sphere for the given density operator.\n\nArguments\n\naxis: Rotation axis.\nangles: Rotation angle(s).\nρ: Density operator that should be rotated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.squeeze","category":"page"},{"location":"api/#CollectiveSpins.quantum.squeeze","page":"API","title":"CollectiveSpins.quantum.squeeze","text":"quantum.squeeze(axis, χT, ρ₀)\n\nSpin squeezing along an arbitrary axis.\n\nArguments\n\naxis: Squeezing axis.\nχT: Squeezing strength.\nρ₀: Operator that should be squeezed.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.quantum.squeezingparameter","category":"page"},{"location":"api/#CollectiveSpins.quantum.squeezingparameter","page":"API","title":"CollectiveSpins.quantum.squeezingparameter","text":"quantum.squeezingparameter(ρ)\n\nCalculate squeezing parameter for the given state.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Methods-cumulant0","page":"API","title":"0th order: Independent spins","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.blochstate","category":"page"},{"location":"api/#CollectiveSpins.independent.blochstate","page":"API","title":"CollectiveSpins.independent.blochstate","text":"independent.blochstate(phi, theta[, N=1])\n\nProduct state of N single spin Bloch states.\n\nAll spins have the same azimuthal angle phi and polar angle theta.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.dim","category":"page"},{"location":"api/#CollectiveSpins.independent.dim","page":"API","title":"CollectiveSpins.independent.dim","text":"independent.dim(state)\n\nNumber of spins described by this state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.splitstate","category":"page"},{"location":"api/#CollectiveSpins.independent.splitstate","page":"API","title":"CollectiveSpins.independent.splitstate","text":"independent.splitstate(state)\n\nSplit state into sx, sy and sz parts.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.densityoperator","category":"page"},{"location":"api/#CollectiveSpins.independent.densityoperator","page":"API","title":"CollectiveSpins.independent.densityoperator","text":"independent.densityoperator(sx, sy, sz)\nindependent.densityoperator(state)\n\nCreate density operator from independent sigma expectation values.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.sx","category":"page"},{"location":"api/#CollectiveSpins.independent.sx","page":"API","title":"CollectiveSpins.independent.sx","text":"independent.sx(state)\n\nSigma x expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.sy","category":"page"},{"location":"api/#CollectiveSpins.independent.sy","page":"API","title":"CollectiveSpins.independent.sy","text":"independent.sy(state)\n\nSigma y expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.sz","category":"page"},{"location":"api/#CollectiveSpins.independent.sz","page":"API","title":"CollectiveSpins.independent.sz","text":"independent.sz(state)\n\nSigma z expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.independent.timeevolution","category":"page"},{"location":"api/#CollectiveSpins.independent.timeevolution","page":"API","title":"CollectiveSpins.independent.timeevolution","text":"independent.timeevolution(T, gamma, state0)\n\nIndependent time evolution.\n\nArguments\n\nT: Points of time for which output will be generated.\ngamma: Decay rate(s).\nstate0: Initial state.\n\n\n\n\n\nindependent.timeevolution(T, S::SpinCollection, state0)\n\nIndependent time evolution.\n\nArguments\n\nT: Points of time for which output will be generated.\nS: SpinCollection describing the system.\nstate0: Initial state.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Methods-cumulant1","page":"API","title":"1st order: Meanfield","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.ProductState","category":"page"},{"location":"api/#CollectiveSpins.meanfield.ProductState","page":"API","title":"CollectiveSpins.meanfield.ProductState","text":"Class describing a Meanfield state (Product state).\n\nThe data layout is [sx1 sx2 ... sy1 sy2 ... sz1 sz2 ...]\n\nArguments\n\nN: Number of spins.\ndata: Vector of length 3*N.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.blochstate","category":"page"},{"location":"api/#CollectiveSpins.meanfield.blochstate","page":"API","title":"CollectiveSpins.meanfield.blochstate","text":"meanfield.blochstate(phi, theta[, N=1])\n\nProduct state of N single spin Bloch states.\n\nAll spins have the same azimuthal angle phi and polar angle theta.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.dim","category":"page"},{"location":"api/#CollectiveSpins.meanfield.dim","page":"API","title":"CollectiveSpins.meanfield.dim","text":"meanfield.dim(state)\n\nNumber of spins described by this state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.splitstate","category":"page"},{"location":"api/#CollectiveSpins.meanfield.splitstate","page":"API","title":"CollectiveSpins.meanfield.splitstate","text":"meanfield.splitstate(N, data)\nmeanfield.splitstate(state)\n\nSplit state into sx, sy and sz parts.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.densityoperator","category":"page"},{"location":"api/#CollectiveSpins.meanfield.densityoperator","page":"API","title":"CollectiveSpins.meanfield.densityoperator","text":"meanfield.densityoperator(sx, sy, sz)\nmeanfield.densityoperator(state)\n\nCreate density operator from independent sigma expectation values.\n\n\n\n\n\nmpc.densityoperator(state)\n\nCreate density operator from MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.sx","category":"page"},{"location":"api/#CollectiveSpins.meanfield.sx","page":"API","title":"CollectiveSpins.meanfield.sx","text":"meanfield.sx(state)\n\nSigma x expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.sy","category":"page"},{"location":"api/#CollectiveSpins.meanfield.sy","page":"API","title":"CollectiveSpins.meanfield.sy","text":"meanfield.sy(state)\n\nSigma y expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.sz","category":"page"},{"location":"api/#CollectiveSpins.meanfield.sz","page":"API","title":"CollectiveSpins.meanfield.sz","text":"meanfield.sz(state)\n\nSigma z expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.timeevolution","category":"page"},{"location":"api/#CollectiveSpins.meanfield.timeevolution","page":"API","title":"CollectiveSpins.meanfield.timeevolution","text":"meanfield.timeevolution(T, S::SpinCollection, state0[; fout])\n\nMeanfield time evolution.\n\nArguments\n\nT: Points of time for which output will be generated.\nS: SpinCollection describing the system.\nstate0: Initial ProductState.\nfout (optional): Function with signature fout(t, state) that is called whenever output   should be generated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.timeevolution_symmetric","category":"page"},{"location":"api/#CollectiveSpins.meanfield.timeevolution_symmetric","page":"API","title":"CollectiveSpins.meanfield.timeevolution_symmetric","text":"meanfield.timeevolution_symmetric(T, state0, Ωeff, Γeff[; γ, δ0, fout])\n\nSymmetric meanfield time evolution.\n\nArguments\n\nT: Points of time for which output will be generated.\nstate0: Initial ProductState.\nΩeff: Effective dipole-dipole interaction.\nΓeff: Effective collective decay rate.\nγ=1: Single spin decay rate.\nδ0=0: Phase shift for rotated symmetric meanfield time evolution.\nfout (optional): Function with signature fout(t, state) that is called whenever output   should be generated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.meanfield.rotate","category":"page"},{"location":"api/#CollectiveSpins.meanfield.rotate","page":"API","title":"CollectiveSpins.meanfield.rotate","text":"meanfield.rotate(axis, angles, state)\n\nRotations on the Bloch sphere for the given ProductState.\n\nArguments\n\naxis: Rotation axis.\nangles: Rotation angle(s).\nstate: ProductState that should be rotated.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Methods-cumulant2","page":"API","title":"2nd order: Meanfield plus Correlations (MPC)","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.MPCState","category":"page"},{"location":"api/#CollectiveSpins.mpc.MPCState","page":"API","title":"CollectiveSpins.mpc.MPCState","text":"Class describing a MPC state (Product state + Correlations).\n\nThe data layout is vector that in matrix form looks like\n\nCxx Cxy Cyy Cxz Czz Cyz\n\nwhere the Cij are the appropriate correlation matrices. The expectation values sx, sy and sz are the diagonals of the matrices Cxx, Cyy and Czz, respectively.\n\nArguments\n\nN: Number of spins.\ndata: Vector of length (3N)(2*N+1).\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.blochstate","category":"page"},{"location":"api/#CollectiveSpins.mpc.blochstate","page":"API","title":"CollectiveSpins.mpc.blochstate","text":"mpc.blochstate(phi, theta[, N=1])\n\nProduct state of N single spin Bloch states.\n\nAll spins have the same azimuthal angle phi and polar angle theta.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.dim","category":"page"},{"location":"api/#CollectiveSpins.mpc.dim","page":"API","title":"CollectiveSpins.mpc.dim","text":"mpc.dim(state)\n\nNumber of spins described by this state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.splitstate","category":"page"},{"location":"api/#CollectiveSpins.mpc.splitstate","page":"API","title":"CollectiveSpins.mpc.splitstate","text":"mpc.splitstate(N, data)\nmpc.splitstate(state)\n\nReturns sx, sy, sz, Cxx, Cyy, Czz, Cxy, Cxz, Cyz.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.correlation2covariance","category":"page"},{"location":"api/#CollectiveSpins.mpc.correlation2covariance","page":"API","title":"CollectiveSpins.mpc.correlation2covariance","text":"mpc.correlation2covariance(corstate)\n\nConvert a MPCState from correlation form into covariance form.\n\nBasically it just calculates Covab = <sa sb> - <sa> <s_b>.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.covariance2correlation","category":"page"},{"location":"api/#CollectiveSpins.mpc.covariance2correlation","page":"API","title":"CollectiveSpins.mpc.covariance2correlation","text":"mpc.covariance2correlation(covstate)\n\nConvert a MPCState from covariance form into correlation form.\n\nBasically it just calculates <sa sb> = Covab + <sa> <s_b>.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.densityoperator(::CollectiveSpins.MPCState)","category":"page"},{"location":"api/#CollectiveSpins.meanfield.densityoperator-Tuple{CollectiveSpins.mpc.MPCState}","page":"API","title":"CollectiveSpins.meanfield.densityoperator","text":"mpc.densityoperator(state)\n\nCreate density operator from MPCState.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.sx","category":"page"},{"location":"api/#CollectiveSpins.mpc.sx","page":"API","title":"CollectiveSpins.mpc.sx","text":"mpc.sx(state)\n\nSigma x expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.sy","category":"page"},{"location":"api/#CollectiveSpins.mpc.sy","page":"API","title":"CollectiveSpins.mpc.sy","text":"mpc.sy(state)\n\nSigma y expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.sz","category":"page"},{"location":"api/#CollectiveSpins.mpc.sz","page":"API","title":"CollectiveSpins.mpc.sz","text":"mpc.sz(state)\n\nSigma z expectation values of state.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Cxx","category":"page"},{"location":"api/#CollectiveSpins.mpc.Cxx","page":"API","title":"CollectiveSpins.mpc.Cxx","text":"mpc.Cxx(state)\n\nSigmax-Sigmax correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Cyy","category":"page"},{"location":"api/#CollectiveSpins.mpc.Cyy","page":"API","title":"CollectiveSpins.mpc.Cyy","text":"mpc.Cyy(state)\n\nSigmay-Sigmay correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Czz","category":"page"},{"location":"api/#CollectiveSpins.mpc.Czz","page":"API","title":"CollectiveSpins.mpc.Czz","text":"mpc.Czz(state)\n\nSigmaz-Sigmaz correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Cxy","category":"page"},{"location":"api/#CollectiveSpins.mpc.Cxy","page":"API","title":"CollectiveSpins.mpc.Cxy","text":"mpc.Cxy(state)\n\nSigmax-Sigmay correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Cxz","category":"page"},{"location":"api/#CollectiveSpins.mpc.Cxz","page":"API","title":"CollectiveSpins.mpc.Cxz","text":"mpc.Cxz(state)\n\nSigmax-Sigmaz correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.Cyz","category":"page"},{"location":"api/#CollectiveSpins.mpc.Cyz","page":"API","title":"CollectiveSpins.mpc.Cyz","text":"mpc.Cyz(state)\n\nSigmay-Sigmaz correlation values of MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.timeevolution","category":"page"},{"location":"api/#CollectiveSpins.mpc.timeevolution","page":"API","title":"CollectiveSpins.mpc.timeevolution","text":"mpc.timeevolution(T, S::SpinCollection, state0[; fout])\n\nMPC time evolution.\n\nArguments\n\nT: Points of time for which output will be generated.\nS: SpinCollection describing the system.\nstate0: Initial MPCState.\nfout (optional): Function with signature fout(t, state) that is called   whenever output should be generated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.rotate","category":"page"},{"location":"api/#CollectiveSpins.mpc.rotate","page":"API","title":"CollectiveSpins.mpc.rotate","text":"mpc.rotate(axis, angles, state)\n\nRotations on the Bloch sphere for the given MPCState.\n\nArguments\n\naxis: Rotation axis.\nangles: Rotation angle(s).\nstate: MPCState that should be rotated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.var_Sx","category":"page"},{"location":"api/#CollectiveSpins.mpc.var_Sx","page":"API","title":"CollectiveSpins.mpc.var_Sx","text":"mpc.var_Sx(state0)\n\nVariance of the total Sx operator for the given MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.var_Sy","category":"page"},{"location":"api/#CollectiveSpins.mpc.var_Sy","page":"API","title":"CollectiveSpins.mpc.var_Sy","text":"mpc.var_Sy(state)\n\nVariance of the total Sy operator for the given MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.var_Sz","category":"page"},{"location":"api/#CollectiveSpins.mpc.var_Sz","page":"API","title":"CollectiveSpins.mpc.var_Sz","text":"mpc.var_Sz(state)\n\nVariance of the total Sz operator for the given MPCState.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.squeeze","category":"page"},{"location":"api/#CollectiveSpins.mpc.squeeze","page":"API","title":"CollectiveSpins.mpc.squeeze","text":"mpc.squeeze(axis, χT, state0)\n\nSpin squeezing along an arbitrary axis.\n\nArguments\n\naxis: Squeezing axis.\nχT: Squeezing strength.\nstate0: MPCState that should be squeezed.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"CollectiveSpins.mpc.squeezingparameter","category":"page"},{"location":"api/#CollectiveSpins.mpc.squeezingparameter","page":"API","title":"CollectiveSpins.mpc.squeezingparameter","text":"mpc.squeezing_parameter(state)\n\nCalculate squeezing parameter for the given state.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Methods-reduced","page":"API","title":"Reduced Spin","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ReducedSpinBasis","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.ReducedSpinBasis","page":"API","title":"CollectiveSpins.reducedspin.ReducedSpinBasis","text":"ReducedSpinBasis(N, M)\n\nBasis for a system of N spin 1/2 systems, up to the M'th excitation.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"reducedspintransition","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedspintransition","page":"API","title":"CollectiveSpins.reducedspin.reducedspintransition","text":"reducedspintransition(b::ReducedSpinBasis, to::Vector{Int}, from::Vector{Int})\n\nTransition operator mathrmtomathrmfrom, where to and from are given as vectors denoting the excitations.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"reducedsigmap","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmap","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmap","text":"reducedsigmap(b::ReducedSpinBasis, j::Int)\n\nSigma Plus Operator for the j-th particle.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"reducedsigmam","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmam","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmam","text":"reducedsigmam(b::ReducedSpinBasis, j::Int)\n\nSigma Minus Operator for the j-th particle.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"reducedsigmax","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmax","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmax","text":"reducedsigmax(b::ReducedSpinBasis, j::Int)\n\nSigma-X Operator for the j-th particle.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"reducedsigmay","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmay","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmay","text":"reducedsigmay(b::ReducedSpinBasis, j::Int)\n\nSigma-Y Operator for the j-th particle.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"reducedsigmaz","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmaz","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmaz","text":"reducedsigmaz(b::ReducedSpinBasis, j::Int)\n\nSigma-Z Operator for the j-th particle.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"reducedsigmapsigmam","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedsigmapsigmam","page":"API","title":"CollectiveSpins.reducedspin.reducedsigmapsigmam","text":"reducedsigmapsigmam(b::ReducedSpinBasis, i, j)\n\nCreate the operator product σᵢ⁺σⱼ⁻ directly on a ReducedSpinBasis. Useful especially for a basis where only one excitation is included, since then the single operators are zero (do not conserve excitation number), but the product is not.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"reducedspinstate","category":"page"},{"location":"api/#CollectiveSpins.reducedspin.reducedspinstate","page":"API","title":"CollectiveSpins.reducedspin.reducedspinstate","text":"reducedspinstate(b::ReducedSpinBasis, inds::Vector{Int})\n\nState where the excitations are placed in the atoms given by inds. Note, that b.MS <= length(inds) <= b.M must be satisfied.\n\nExamples\n\njulia> b = CollectiveSpins.ReducedSpinBasis(4,2)\nReducedSpin(N=4, M=2, MS=0)\n\njulia> GS = CollectiveSpins.reducedspinstate(b,[]) # get the ground state\nKet(dim=11)\n  basis: ReducedSpin(N=4, M=2, MS=0)\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\njulia> ψ2 = CollectiveSpins.reducedspinstate(b,[1,2]) # First and second atom excited\nKet(dim=11)\n  basis: ReducedSpin(N=4, M=2, MS=0)\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Collective-Modes","page":"API","title":"Collective Modes","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Omega_k_chain","category":"page"},{"location":"api/#CollectiveSpins.collective_modes.Omega_k_chain","page":"API","title":"CollectiveSpins.collective_modes.Omega_k_chain","text":"Omega_k_chain(k, a, polarization)\n\nCollective frequency shift Omega_k of mode k for an infinite chain of atoms along x-axis.\n\nWLOG, this calculation scales natural atomic frequency wavelength lambda0=1 and decay rate gamma0=1.\n\nArguments\n\nk: x-axis quasimomentum of collective mode in first BZ such that |k|<= pi/a.\na: Atomic lattice spacing.\npolarization: 3D, complex vector of atomic polarization.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Gamma_k_chain","category":"page"},{"location":"api/#CollectiveSpins.collective_modes.Gamma_k_chain","page":"API","title":"CollectiveSpins.collective_modes.Gamma_k_chain","text":"Gamma_k_chain(k, a, polarization)\n\nCollective decay rate Gamma_k of mode k for an infinite chain of atoms along x-axis.\n\nWLOG, this calculation scales natural atomic frequency wavelength lambda0=1 and decay rate gamma0=1.\n\nArguments\n\nk: x-axis quasimomentum of collective mode in first BZ such that |k|<= pi/a.\na: Atomic lattice spacing.\npolarization: 3D, complex vector of atomic polarization.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Omega_k_2D","category":"page"},{"location":"api/#CollectiveSpins.collective_modes.Omega_k_2D","page":"API","title":"CollectiveSpins.collective_modes.Omega_k_2D","text":"Omega_k_2D(k_vec, a_vec1, a_vec2, polarization)\n\nCollective frequency shift Omegak of in-plane mode kvec for an 2D array of atoms in yz-plane.\n\nWLOG, this calculation scales natural atomic frequency wavelength lambda0=1 and decay rate gamma0=1.\n\nArguments\n\nk_vec: yz-axis quasimomentum of collective mode in first BZ such that |k|<= pi/a.\na_vec1, a_vec2: 2D Bravais lattice vectors.\npolarization: 3D, complex vector of atomic polarization.\nLambda: Cutoff frequency of renormalization.\nN1: Number of terms in a_vec1 reciprocal lattice direction.\nN2: Number of terms in a_vec2 reciprocal lattice direction.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"Gamma_k_2D","category":"page"},{"location":"api/#CollectiveSpins.collective_modes.Gamma_k_2D","page":"API","title":"CollectiveSpins.collective_modes.Gamma_k_2D","text":"Gamma_k_2D(k_vec, a_vec1, a_vec2, polarization)\n\nCollective decay rate Gammak of in-plane mode kvec for an 2D array of atoms in yz-plane.\n\nWLOG, this calculation scales natural atomic frequency wavelength lambda0=1 and decay rate gamma0=1.\n\nArguments\n\nk_vec: yz-axis quasimomentum of collective mode in first BZ such that |k|<= pi/a.\na_vec1, a_vec2: 2D Bravais lattice vectors.\npolarization: 3D, complex vector of atomic polarization.\n\n\n\n\n\n","category":"function"},{"location":"geometry/#Geometry","page":"Geometry","title":"Geometry","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"In order to simplify creation of various particle distributions, a few helper functions with self-explanatory names are provided:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"geometry.chain\ngeometry.triangle\ngeometry.rectangle\ngeometry.square\ngeometry.hexagonal\ngeometry.box\ngeometry.cube\ngeometry.ring","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"They can be used directly to create a SpinCollection:","category":"page"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"using CollectiveSpins # hide\nSpinCollection(geometry.chain(0.5, 6), [0,0,1])\nnothing # hide","category":"page"},{"location":"system/#System","page":"System","title":"System","text":"","category":"section"},{"location":"system/","page":"System","title":"System","text":"The basic building blocks used in CollectiveSpins.jl are, not surprisingly, spins. They are defined by their position and a frequency Delta describing a shift relative to the frequency of the rotating frame in use:","category":"page"},{"location":"system/","page":"System","title":"System","text":"struct Spin{T1,T2} <: System\n    position::T1\n    delta::T2\nend","category":"page"},{"location":"system/","page":"System","title":"System","text":"Defining the frequency is optional and is set to zero by default:","category":"page"},{"location":"system/","page":"System","title":"System","text":"using CollectiveSpins # hide\nSpin([0,0,0]; delta=1)\nSpin([0,0,0])\nnothing # hide","category":"page"},{"location":"system/","page":"System","title":"System","text":"Combining many spins into one big system can be done by using the SpinCollection type. All contained spins must have the same polarization axis and decay rate gamma:","category":"page"},{"location":"system/","page":"System","title":"System","text":"struct SpinCollection{S<:Spin,P<:Vector,G<:Real} <: System\n    spins::Vector{S}\n    polarizations::Vector{P}\n    gammas::Vector{G}\nend","category":"page"},{"location":"system/","page":"System","title":"System","text":"For convenience one can create a SpinCollection without explicitly constructing the single spins first::","category":"page"},{"location":"system/","page":"System","title":"System","text":"SpinCollection([[0,0,0], [1,0,0]], [0,0,1]; gammas=2, deltas=1)","category":"page"},{"location":"system/","page":"System","title":"System","text":"Adding a cavity can be done with the CavityMode type:","category":"page"},{"location":"system/","page":"System","title":"System","text":"struct CavityMode{C<:Int,T1<:Number,T2<:Number,T3<:Number} <: System\n    cutoff::C\n    delta::T1\n    eta::T2\n    kappa::T3\nend","category":"page"},{"location":"system/","page":"System","title":"System","text":"which can be coupled to a spin collection with coupling strength g via the CavitySpinCollection type:","category":"page"},{"location":"system/","page":"System","title":"System","text":"struct CavitySpinCollection{C<:CavityMode,S<:SpinCollection,G<:Number} <: System\n    cavity::C\n    spincollection::S\n    g::Vector{G}\nend","category":"page"},{"location":"reducedspin/#Reduced-Spin","page":"Reduced Spin","title":"Reduced Spin","text":"","category":"section"},{"location":"reducedspin/","page":"Reduced Spin","title":"Reduced Spin","text":"A common approach to treating many spins quantum mechanically is to truncate the Hilbert space at a specific number of excitations. This widely reduces the number of possible states. CollectiveSpins.jl offers generic functionality to truncate a system of spins at an arbitrary number of excitations. The following functions can be used, and are largely equivalent to the SpinBasis implemented in QuantumOptics.jl.","category":"page"},{"location":"reducedspin/","page":"Reduced Spin","title":"Reduced Spin","text":"ReducedSpinBasis\nreducedspintransition\nreducedsigmap\nreducedsigmam\nreducedsigmax\nreducedsigmay\nreducedsigmaz\nreducedsigmapsigmam\nreducedspinstate","category":"page"},{"location":"reducedspin/#Example","page":"Reduced Spin","title":"Example","text":"","category":"section"},{"location":"reducedspin/","page":"Reduced Spin","title":"Reduced Spin","text":"Let us illustrate how to work with the reducedspin submodule. In the following example, we will compute the intensity radiation pattern of a regular chain of atoms in a subradiant state from A. Asenjo-Garcia et al, 10.1103/PhysRevX.7.031024 (Fig. 3b).","category":"page"},{"location":"reducedspin/","page":"Reduced Spin","title":"Reduced Spin","text":"using CollectiveSpins\nusing QuantumOptics\nusing PyPlot\n\n# Parameters\nN = 50\nM = 1 # Number of excitations\nd = 0.33\npos = geometry.chain(d,N)\nμ = [[1.0,0,0] for i=1:N]\nS = SpinCollection(pos,μ)\n\n# Collective effects\nΩmat = OmegaMatrix(S)\nΓmat = GammaMatrix(S)\n\n# Hilbert space\nb = ReducedSpinBasis(N,M,M) # Basis from M excitations up to M excitations\n\n# Effective Hamiltonian\nspsm = [reducedsigmapsigmam(b, i, j) for i=1:N, j=1:N]\nH_eff = dense(sum((Ωmat[i,j] - 0.5im*Γmat[i,j])*spsm[i, j] for i=1:N, j=1:N))\n\n# Find the most subradiant eigenstate\nλ, states = eigenstates(H_eff; warning=false)\nγ = -2 .* imag.(λ)\ns_ind = findmin(γ)[2]\nψ = states[s_ind]\n\n# Compute the radiation pattern\nfunction G(r,i,j) # Green's Tensor overlap\n    G_i = GreenTensor(r-pos[i])\n    G_j = GreenTensor(r-pos[j])\n    return μ[i]' * (G_i'*G_j) * μ[j]\nend\nfunction intensity(r) # The intensity ⟨E⁻(r)⋅E⁺(r)⟩\n    real(sum(expect(spsm[i,j], ψ)*G(r,i,j) for i=1:N, j=1:N))\nend\n\ny = -50d:2d:50d\nz = 5d\nx = y .+ 0.5d*(N-1)\nI = zeros(length(x), length(y))\nfor i=1:length(x), j=1:length(y)\n    I[i,j] = intensity([x[i],y[j],z])\nend\n\n# Plot\nfigure(figsize=(9,4))\ncontourf(x./d,y./d,I',30)\nfor p in pos\n    plot(p[1]./d,p[2],\"o\",color=\"w\",ms=2)\nend\nxlabel(\"x/d\")\nylabel(\"y/d\")\ncolorbar(label=\"Intensity\",ticks=[])\ntight_layout()\nsavefig(\"radiation-pattern.png\") # hide","category":"page"},{"location":"reducedspin/","page":"Reduced Spin","title":"Reduced Spin","text":"(Image: )","category":"page"},{"location":"interaction/#Dipole-Dipole-interaction","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"","category":"section"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"Of course the core of this library are the equations describing the dipole-dipole interaction and the collective decay","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"beginaligned\nGamma_ij = frac32 sqrtGamma_i Gamma_j F_ij(k_a r_ij) \nOmega_ij = frac34 sqrtGamma_i Gamma_j G_ij(k_a r_ij)\nendaligned","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"with","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"beginaligned\nF_ij(xi) =\n            big( 1 - (vece^(r)  vece^(d_eg))^2 big) fracsin xixi\n            + big( 1 - 3 (vece^(r)  vece^(d_eg))^2 big)\n                big( fraccos xixi^2 - fracsin xixi^3big)\n\nG_ij(xi) =\n             - big(1 - (vece^(r)  vece^(d_eg))^2 big) fraccos xixi\n            + big( 1 - 3 (vece^(r)  vece^(d_eg))^2 big)\n                big( fracsin xixi^2 - fraccos xixi^3big)\nendaligned","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"They are implemented in the functions:","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"CollectiveSpins.interaction.Omega\nCollectiveSpins.interaction.Gamma","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"To create the interaction matrices the following two shortcuts are provided:","category":"page"},{"location":"interaction/","page":"Dipole-Dipole interaction","title":"Dipole-Dipole interaction","text":"CollectiveSpins.interaction.GammaMatrix\nCollectiveSpins.interaction.OmegaMatrix","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install the latest official release, you can use Julia's internal package manager. Simply start the Julia interpreter, press the ] key and type","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"\tpkg> add CollectiveSpins","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The source code is available on GitHub at https://github.com/qojulia/CollectiveSpins.jl (Note: this version may be unstable). You can also use Julia's package manager to checkout this version.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"\tpkg> develop CollectiveSpins","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Alternatively, you can use git to clone the repository.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"\t>> git clone https://github.com/qojulia/CollectiveSpins.jl.git","category":"page"},{"location":"descriptions/#Theoretical-Descriptions","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"","category":"section"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"CollectiveSpins.jl provides several different possibilities to simulate multi-spin systems. A full quantum description is available but only possible for small numbers of spins. Additionally, approximations of different orders are implemented using a cumulant expansion approach:","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"quantum - descriptions-quantum\nindependent - descriptions-cumulant0\nmeanfield - descriptions-cumulant1\nmpc - descriptions-cumulant2","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"All variants provide a unified interface wherever possible:","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"blochstate(phi, theta)\ndensityoperator(state)\nsx(state)\nsy(state)\nsz(state)\ntimeevolution(T, system, state0; fout=nothing)\nrotate(axis, angles, state)\nsqueeze(axis, χT, state)\nsqueezingparameter(state)","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"The following example should give a first idea how these implementations are used:","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"using QuantumOptics, CollectiveSpins\nconst cs = CollectiveSpins\n\n# System parameters\nconst a = 0.18\nconst γ = 1.\nconst e_dipole = [0,0,1.]\nconst T = [0:0.05:5;]\nconst N = 5\nconst Ncenter = 3\n\nconst system = SpinCollection(cs.geometry.chain(a, N), e_dipole, γ)\n\n\n# Define Spin 1/2 operators\nspinbasis = SpinBasis(1//2)\nsx = sigmax(spinbasis)\nsy = sigmay(spinbasis)\nsz = sigmaz(spinbasis)\nsp = sigmap(spinbasis)\nsm = sigmam(spinbasis)\nI_spin = identityoperator(spinbasis)\n\n# Initial state (Bloch state)\nconst phi = 0.\nconst theta = pi/2.\n\n# Time evolution\n\n# Independent\nstate0 = cs.independent.blochstate(phi, theta, N)\ntout, state_ind_t = cs.independent.timeevolution(T, system, state0)\n\n# Meanfield\nstate0 = cs.meanfield.blochstate(phi, theta, N)\ntout, state_mf_t = cs.meanfield.timeevolution(T, system, state0)\n\n# Meanfield + Correlations\nstate0 = cs.mpc.blochstate(phi, theta, N)\ntout, state_mpc_t = cs.mpc.timeevolution(T, system, state0)\n\n# Quantum: master equation\nsx_master = Float64[]\nsy_master = Float64[]\nsz_master = Float64[]\n\ntd_ind = Float64[]\ntd_mf  = Float64[]\ntd_mpc = Float64[]\n\nembed(op::Operator) = QuantumOptics.embed(cs.quantum.basis(system), Ncenter, op)\n\nfunction fout(t, rho)\n    i = findfirst(isequal(t), T)\n    rho_ind = cs.independent.densityoperator(state_ind_t[i])\n    rho_mf  = cs.meanfield.densityoperator(state_mf_t[i])\n    rho_mpc = cs.mpc.densityoperator(state_mpc_t[i])\n    push!(td_ind, tracedistance(rho, rho_ind))\n    push!(td_mf,  tracedistance(rho, rho_mf))\n    push!(td_mpc, tracedistance(rho, rho_mpc))\n    push!(sx_master, real(expect(embed(sx), rho)))\n    push!(sy_master, real(expect(embed(sy), rho)))\n    push!(sz_master, real(expect(embed(sz), rho)))\n    return nothing\nend\n\nΨ₀ = cs.quantum.blochstate(phi,theta,N)\nρ₀ = Ψ₀⊗dagger(Ψ₀)\ncs.quantum.timeevolution(T, system, ρ₀, fout=fout)\n\n# Expectation values\nmapexpect(op, states) = map(s->(op(s)[Ncenter]), states)\n\nsx_ind = mapexpect(cs.independent.sx, state_ind_t)\nsy_ind = mapexpect(cs.independent.sy, state_ind_t)\nsz_ind = mapexpect(cs.independent.sz, state_ind_t)\n\nsx_mf = mapexpect(cs.meanfield.sx, state_mf_t)\nsy_mf = mapexpect(cs.meanfield.sy, state_mf_t)\nsz_mf = mapexpect(cs.meanfield.sz, state_mf_t)\n\nsx_mpc = mapexpect(cs.mpc.sx, state_mpc_t)\nsy_mpc = mapexpect(cs.mpc.sy, state_mpc_t)\nsz_mpc = mapexpect(cs.mpc.sz, state_mpc_t)\nnothing # hide","category":"page"},{"location":"descriptions/#descriptions-quantum","page":"Theoretical Descriptions","title":"Quantum","text":"","category":"section"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"The time evolution of the N spins in a rotating frame corresponding to sum_i omega_0 sigma^z_i is then governed by a master equation","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"dotrho = -fracihbar bigH rhobig + mathcalLrho","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"with the Hamiltonian","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"H = sum_iji neq j hbar Omega_ij sigma_i^+ sigma_j^-","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"and Lindblad-term","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"mathcalLrho = frac12 sum_ij Gamma_ij\n                    (2sigma_i^- rho sigma_j^+\n                    - sigma_i^+ sigma_j^- rho\n                    - rho sigma_i^+ sigma_j^-)","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"The dipole-dipole interaction Omega_ij = frac34 gamma G(k_0 r_ij) and the collective decay Gamma_ij = frac32 gamma F(k_0 r_ij) can be obtained analytically with","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginaligned\nF(xi) = alpha fracsin xixi\n        + beta left(\n              fraccos xixi^2 - fracsin xixi^3\n        right)\n\nG(xi) = -alpha fraccos xixi + beta left(\n            fracsin xixi^2 + fraccos xixi^3\n        right)\nendaligned","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"with alpha = 1 -cos^2 theta and beta = 1-3 cos^2 theta, where theta represents the angle between the line connecting atoms i and j and the common atomic dipole orientation.","category":"page"},{"location":"descriptions/#descriptions-cumulant0","page":"Theoretical Descriptions","title":"0th order: Independent spins","text":"","category":"section"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"Each spin evolves independently according to","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginaligned\nlangledotsigma_k^xrangle  =\n  -frac12 gamma langlesigma_k^xrangle\n\nlangledotsigma_k^yrangle  =\n  -frac12 gamma langlesigma_k^yrangle\n\nlangledotsigma_k^zrangle =\n    gamma big(1 - langlesigma_k^zranglebig)\nendaligned","category":"page"},{"location":"descriptions/#descriptions-cumulant1","page":"Theoretical Descriptions","title":"1st order: Meanfield","text":"","category":"section"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginaligned\nlangledotsigma_k^xrangle  =\n  sum_ii neq k Omega_ki langlesigma_i^ysigma_k^zrangle\n  -frac12 gamma langlesigma_k^xrangle\n  -frac12 sum_ii neq k Gamma_ki langlesigma_i^xsigma_k^zrangle\n\nlangledotsigma_k^yrangle  =\n  -sum_ii neq k Omega_ki langlesigma_i^xsigma_k^zrangle\n  -frac12 gamma langlesigma_k^yrangle\n  -frac12 sum_ii neq k Gamma_ki langlesigma_i^ysigma_k^zrangle\n\nlangledotsigma_k^zrangle =\n    - sum_ii neq k Omega_ki Big(langlesigma_k^xsigma_i^yrangle - langlesigma_i^xsigma_k^yrangleBig)\n    +gamma big(1 - langlesigma_k^zranglebig)\n    +frac12 sum_ii neq k Gamma_ki Big(langlesigma_k^xsigma_i^xrangle + langlesigma_i^ysigma_k^yrangleBig)\n  endaligned","category":"page"},{"location":"descriptions/#descriptions-cumulant2","page":"Theoretical Descriptions","title":"2nd order: Meanfield plus Correlations (MPC)","text":"","category":"section"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginaligned\nlangledotsigma_k^xsigma_l^xrangle =\n  sum_jj neq kl Omega_kj langlesigma_k^zsigma_l^xsigma_j^yrangle\n   + sum_jj neq kl Omega_lj langlesigma_k^xsigma_l^zsigma_j^yrangle\nqquad\n  - gamma langlesigma_k^xsigma_l^xrangle\n  + Gamma_kl Big(\n          langlesigma_k^zsigma_l^zrangle\n          - frac12 langlesigma_k^zrangle\n          - frac12 langlesigma_l^zrangle\n    Big)\nquad\n    - frac12 sum_jj neq kl Gamma_kj\n          langlesigma_k^zsigma_l^xsigma_j^xrangle\n    - frac12 sum_jj neq kl Gamma_lj\n          langlesigma_k^xsigma_l^zsigma_j^xrangle\n\nlangledotsigma_k^ysigma_l^yrangle\n= - sum_jj neq kl Omega_kj\n      langlesigma_k^zsigma_l^ysigma_j^xrangle\n    - sum_jj neq kl Omega_lj\n      langlesigma_k^ysigma_l^zsigma_j^xrangle\nqquad\n    - gamma langlesigma_k^ysigma_l^yrangle\n    + Gamma_klBig(\n          langlesigma_k^zsigma_l^zrangle\n        -frac12 langlesigma_k^zrangle\n        -frac12 langlesigma_l^zrangle\n    Big)\nquad\n    -frac12 sum_jj neq kl Gamma_kj\n          langlesigma_k^zsigma_l^ysigma_j^yrangle\n    -frac12 sum_jj neq kl Gamma_lj\n          langlesigma_k^ysigma_l^zsigma_j^yrangle\n\nlangledotsigma_k^zsigma_l^zrangle\n= sum_jj neq kl Omega_kj Big(\n      langlesigma_k^ysigma_l^zsigma_j^xrangle\n      - langlesigma_k^xsigma_l^zsigma_j^yrangle\n    Big)\nqquad\n    +sum_jj neq kl Omega_lj Big(\n      langlesigma_k^zsigma_l^ysigma_j^xrangle\n      -langlesigma_k^zsigma_l^xsigma_j^yrangle\n    Big)\nquad\n    - 2 gamma langlesigma_k^zsigma_l^zrangle\n    + gamma big(langlesigma_l^zrangle + langlesigma_k^zranglebig)\nquad\n    +Gamma_klBig(\n          langlesigma_k^ysigma_l^yrangle\n          + langlesigma_k^xsigma_l^xrangle\n    Big)\nquad\n    +frac12 sum_jj neq kl Gamma_kj Big(\n          langlesigma_k^xsigma_l^zsigma_j^xrangle\n          +langlesigma_k^ysigma_l^zsigma_j^yrangle\n    Big)\nqquad\n    +frac12 sum_jj neq kl Gamma_lj Big(\n          langlesigma_k^zsigma_l^xsigma_j^xrangle\n          +langlesigma_k^zsigma_l^ysigma_j^yrangle\n    Big)\nendaligned","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginaligned\nlangledotsigma_k^xsigma_l^yrangle\n= Omega_klBig(\n      langlesigma_k^zrangle\n      - langlesigma_l^zrangle\n    Big)\n    +sum_jj neq kl Omega_kj\n      langlesigma_k^zsigma_l^ysigma_j^yrangle\nqquad\n    -sum_jj neq kl Omega_lj\n      langlesigma_k^xsigma_l^zsigma_j^xrangle\n    - gamma langlesigma_k^xsigma_l^yrangle\nquad\n    - frac12 sum_jj neq kl Gamma_kj\n          langlesigma_k^zsigma_l^ysigma_j^xrangle\n    - frac12 sum_jj neq kl Gamma_lj\n          langlesigma_k^xsigma_l^zsigma_j^yrangle\n\nlangledotsigma_k^xsigma_l^zrangle\n= Omega_kl\n      langlesigma_l^yrangle\n    +sum_jj neq kl Omega_kj\n      langlesigma_k^zsigma_l^zsigma_j^yrangle\nquad\n    +sum_jj neq kl Omega_lj Big(\n      langlesigma_k^xsigma_l^ysigma_j^xrangle\n      -langlesigma_k^xsigma_l^xsigma_j^yrangle\n    Big)\nquad\n- frac32 gamma langlesigma_k^xsigma_l^zrangle\n  + gamma langlesigma_k^xrangle\n  - Gamma_klBig(\n        langlesigma_k^zsigma_l^xrangle\n        -frac12 langlesigma_l^xrangle\n    Big)\nquad\n    - frac12 sum_jj neq kl Gamma_kj\n          langlesigma_k^zsigma_l^zsigma_j^xrangle\nquad\n    + frac12 sum_jj neq kl Gamma_lj Big(\n          langlesigma_k^xsigma_l^xsigma_j^xrangle\n          +langlesigma_k^xsigma_l^ysigma_j^yrangle\n    Big)\nendaligned","category":"page"},{"location":"descriptions/","page":"Theoretical Descriptions","title":"Theoretical Descriptions","text":"beginaligned\nlangledotsigma_k^ysigma_l^zrangle\n= -Omega_kl langlesigma_l^xrangle\n    -sum_jj neq kl Omega_kj\n      langlesigma_k^zsigma_l^zsigma_j^xrangle\nquad\n    +sum_jj neq kl Omega_lj Big(\n      langlesigma_k^ysigma_l^ysigma_j^xrangle\n      -langlesigma_k^ysigma_l^xsigma_j^yrangle\n    Big)\nquad\n  - frac32 gamma langlesigma_k^ysigma_l^zrangle\n  + gamma langlesigma_k^yrangle\n  - Gamma_klBig(\n          langlesigma_k^zsigma_l^yrangle\n        - frac12langlesigma_l^yrangle\n    Big)\nquad\n    - frac12 sum_jj neq kl Gamma_kj\n          langlesigma_k^zsigma_l^zsigma_j^yrangle\nquad\n    + frac12 sum_jj neq kl Gamma_lj Big(\n          langlesigma_k^ysigma_l^xsigma_j^xrangle\n          +langlesigma_k^ysigma_l^ysigma_j^yrangle\n    Big)\nendaligned","category":"page"},{"location":"effective_interaction/#Effective-Interactions","page":"Effective Interactions","title":"Effective Interactions","text":"","category":"section"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"Effective interactions occur in the equations of motion of large spin systems that have certain symmetries so that the dynamics of every single spin is identical:","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\nlangledotsigma^xrangle =\n  Omega^mathrmefflanglesigma^yranglelanglesigma^zrangle\n  -frac12 Big(\n      gamma\n    -Gamma^mathrmefflanglesigma^zrangle\n  Big) langlesigma^xrangle\n\nlangledotsigma^yrangle =\n  -Omega^mathrmefflanglesigma^xranglelanglesigma^zrangle\n  -frac12 Big(\n    gamma\n    -Gamma^mathrmefflanglesigma^zrangle\n  Big) langlesigma^yrangle\n\nlangledotsigma^zrangle =\n    -gamma big(1 + langlesigma^zranglebig)\n    -frac12 Gamma^mathrmeff Big(langlesigma^xrangle^2 + langlesigma^yrangle^2Big)\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"These quantities encapsulate the influence of all spins onto one single spin:","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\nOmega^mathrmeff = sum_j=2^N Omega_1j\n\nGamma^mathrmeff = sum_j=2^N Gamma_1j\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"The following functions can be used to easily calculate them for common examples:","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"CollectiveSpins.effective_interaction.triangle_orthogonal\nCollectiveSpins.effective_interaction.square_orthogonal\nCollectiveSpins.effective_interaction.rectangle_orthogonal\nCollectiveSpins.effective_interaction.cube_orthogonal\nCollectiveSpins.effective_interaction.box_orthogonal\nCollectiveSpins.effective_interaction.chain\nCollectiveSpins.effective_interaction.chain_orthogonal\nCollectiveSpins.effective_interaction.squarelattice_orthogonal\nCollectiveSpins.effective_interaction.hexagonallattice_orthogonal\nCollectiveSpins.effective_interaction.cubiclattice_orthogonal\nCollectiveSpins.effective_interaction.tetragonallattice_orthogonal\nCollectiveSpins.effective_interaction.hexagonallattice3d_orthogonal","category":"page"},{"location":"effective_interaction/#Rotated-effective-interactions","page":"Effective Interactions","title":"Rotated effective interactions","text":"","category":"section"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"If we allow for the individual atomic states to bare a spatially dependent phase of Delta phi on the excited state, i.e. psi_krangle = frac1sqrt2 left( grangle + exp (i phi_k) erangle right),  we can absorb this into our equations efficiently. Using the abbreviations Omega_kj^mathrmcos = Omega_kj cos(phi_k - phi_j) and Omega_kj^mathrmsin = Omega_kj sin(phi_k - phi_j) we obtain the following modified equations of motion","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\nfracddtlangletildesigma_k^xrangle\n= sum_jj neq k Omega_kj^mathrmsin langletildesigma_j^xsigma_k^zrangle\n        + sum_jj neq k Omega_kj^mathrmcos langletildesigma_j^ysigma_k^zrangle\n    -frac12 gamma langletildesigma_k^xrangle\n    +frac12 sum_jj neq k Gamma_kj^mathrmcos langletildesigma_j^x sigma_k^zrangle\n        -frac12sum_jj neq k Gamma_kj^mathrmsin langletildesigma_j^y sigma_k^zrangle\n\nfracddtlangletildesigma_k^yrangle\n= -sum_jj neq k Omega_kj^mathrmcos langletildesigma_j^xsigma_k^zrangle\n        + sum_jj neq k Omega_kj^mathrmsin langletildesigma_j^ysigma_k^zrangle\n    -frac12 gamma langletildesigma_k^yrangle\n    +frac12 sum_jj neq k Gamma_kj^mathrmsin langletildesigma_j^x sigma_k^zrangle\n    +frac12 sum_jj neq k Gamma_kj^mathrmcos langletildesigma_j^y sigma_k^zrangle\n\nfracddtlanglesigma_k^zrangle\n= -sum_jj neq k Omega_kj^mathrmsin (\n            langletildesigma_j^x tildesigma_k^xrangle\n            + langletildesigma_j^y tildesigma_k^yrangle)\n    +sum_jj neq k Omega_kj^mathrmcos (\n            langletildesigma_j^x tildesigma_k^yrangle\n            - langletildesigma_j^y tildesigma_k^xrangle)\n  qquad\n    -gamma (1+ langlesigma_k^zrangle)\n    -frac12 sum_jj neq k Gamma_kj^mathrmcos (\n            langletildesigma_j^x tildesigma_k^xrangle\n            + langletildesigma_j^y tildesigma_k^yrangle)\n    -frac12 sum_jj neq k Gamma_kj^mathrmsin (\n            langletildesigma_j^x tildesigma_k^yrangle\n            - langletildesigma_j^y tildesigma_k^xrangle)\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"We see that the following definitions prove to be very helpful","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\nOmega_k^mathrmcos = sum_jj neq k Omega_kj cos(phi_k-phi_j)\nqquad\nOmega_k^mathrmsin = sum_jj neq k Omega_kj sin(phi_k-phi_j)\n\nGamma_k^mathrmcos = sum_jj neq k Gamma_kj cos(phi_k-phi_j)\nqquad\nGamma_k^mathrmsin = sum_jj neq k Gamma_kj sin(phi_k-phi_j)\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"Again, if we consider highly symmetric configurations where Omega^mathrmf = Omega^mathrmf_k and Gamma^mathrmf = Gamma^mathrmf_k and the rotated states are initially identical we can define the effective rotated quantities","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\ntildeOmega^mathrmeff = Omega^mathrmcos - frac12 Gamma^mathrmsin\n\ntildeGamma^mathrmeff = Gamma^mathrmcos + 2 Omega^mathrmsin\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"which lead to a closed set of simplified effective equations as well, i.e.","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"beginaligned\nfracddtlangletildesigma^xrangle  =\n  tildeOmega^mathrmefflangletildesigma^yranglelanglesigma^zrangle\n  -frac12 gamma langletildesigma^xrangle\n  +frac12 tildeGamma^mathrmeff langletildesigma^xranglelanglesigma^zrangle\n\nfracddtlangletildesigma^yrangle  =\n  -tildeOmega^mathrmefflangletildesigma^xranglelanglesigma^zrangle\n  -frac12 gamma langletildesigma^yrangle\n  +frac12 tildeGamma^mathrmeff langletildesigma^yranglelanglesigma^zrangle\n\nfracddtlanglesigma^zrangle  =\n    -gamma big(1 + langlesigma^zranglebig)\n    -frac12 tildeGamma^mathrmeff Big(langletildesigma^xrangle^2 + langletildesigma^yrangle^2Big)\nendaligned","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"The calculation of these quantities for a few systems is implemented by:","category":"page"},{"location":"effective_interaction/","page":"Effective Interactions","title":"Effective Interactions","text":"CollectiveSpins.effective_interaction_rotated.square_orthogonal\nCollectiveSpins.effective_interaction_rotated.cube_orthogonal\nCollectiveSpins.effective_interaction_rotated.chain_orthogonal","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CollectiveSpins.jl is a numerical framework that can be used to simulate quantum systems consisting of spatially distributed spins interacting via Dipole-Dipole interaction, optionally coupled to a cavity.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The Geometry module allows the rapid creation of arbitrarily placed spins in order to build up very general systems as explained in the System documentation. These can then be investigated using either a complete quantum description or cumulant expansions up to second order. The details are presented in Theoretical Descriptions. The Collective Modes provides functions for the calculation of collective spin band structures and decay rates.","category":"page"},{"location":"collective_modes/#Collective-Modes","page":"Collective Modes","title":"Collective Modes","text":"","category":"section"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"A module that calculates the band structure and decay rates of different collective modes of quasimomentum k with functions:","category":"page"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"Omega_k_chain\nGamma_k_chain\nOmega_k_2D\nGamma_k_2D","category":"page"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"It is probably best to illustrate the functionality using some examples.","category":"page"},{"location":"collective_modes/#One-dimensional-case","page":"Collective Modes","title":"One-dimensional case","text":"","category":"section"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"The following code reproduces the band strucuture and decay plots from A. Asenjo-Garcia et al, 10.1103/PhysRevX.7.031024 (Figs. 1b and 1c).","category":"page"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"using CollectiveSpins\n\n# Define chain parameters\na = 0.2   # spin-spin distance\npolarization_par = [1, 0, 0]\npolarization_perp = [0, 1, 1]\n\nk_max = 10000\nk_list = [iii*pi/(a*k_max) for iii=-k_max:k_max]\n\nband_structure_par = []\nband_structure_perp = []\ndecay_par = []\ndecay_perp = []\nfor k in k_list\n    append!(band_structure_par, Omega_k_chain(k, a, polarization_par))\n    append!(band_structure_perp, Omega_k_chain(k, a, polarization_perp))\n    append!(decay_par, Gamma_k_chain(k, a, polarization_par))\n    append!(decay_perp, Gamma_k_chain(k, a, polarization_perp))\nend\n\nusing PyPlot\n\nfigure()\nsubplot(211)\nplot(k_list*a/pi, band_structure_par)\nplot(k_list*a/pi, band_structure_perp, color=\"red\")\nxlabel(\"k d/pi\")\nylabel(\"Omega(k)/gamma0\")\n\nsubplot(212)\nplot(k_list*a/pi, decay_par)\nplot(k_list*a/pi, decay_perp, color=\"red\")\nxlabel(\"k d/pi\")\nylabel(\"Gamma(k)/gamma0\")\n\ntight_layout()\nsavefig(\"band_structure_decay_1D.svg\") # hide","category":"page"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"(Image: )","category":"page"},{"location":"collective_modes/#Two-dimensional-case","page":"Collective Modes","title":"Two-dimensional case","text":"","category":"section"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"For the two-dimensional case, consider the following two examples. The first example reproduces the band structure for a 2D square lattice with in-plane circularly polarized and perpendicular (x-axis) polarized atoms, which can be found in E. Shahmoon et al 10.1103/PhysRevLett.118.113601 (Fig. 4a).","category":"page"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"For a particularly elegant derivation of collective frequency shifts and decay rates in 2D atomic arrays, see the thesis of Dominik Wild, \"Algorithms and Platforms for Quantum Science and Technology\".","category":"page"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"using CollectiveSpins\nusing PyPlot\n\npolarization_par = [0, 1, im]\npolarization_perp = [1, 0, 0]\na_vec1 = [0.2, 0]\na_vec2 = [0, 0.2]\nk_max = 200\n\nk_listy = [iii*pi/(a_vec1[1]*k_max) for iii=k_max:-1:0]\nk_listz = copy(k_listy)\nk_listy = append!(k_listy, [iii*pi/(a_vec1[1]*k_max) for iii=0:k_max])\nk_listz = append!(k_listz, zeros(k_max+1))\nk_listy = append!(k_listy, ones(k_max+1)*pi/a_vec1[1])\nk_listz = append!(k_listz, [iii*pi/(a_vec1[1]*k_max) for iii=0:k_max])\nk_dim = length(k_listy)\n\nbandstructure_par = zeros(k_dim)\nbandstructure_perp = zeros(k_dim)\nfor iii=1:k_dim\n    k = [k_listy[iii], k_listz[iii]]\n    bandstructure_par[iii] = Omega_k_2D(k, a_vec1, a_vec2, polarization_par)\n    bandstructure_perp[iii] = Omega_k_2D(k, a_vec1, a_vec2, polarization_perp)\nend\n\npositions = [0, k_max, 2*k_max, 3*k_max]\nlabels = [\"M\", \"Gamma\", \"X\", \"M\"]\n\nfigure(figsize=(6,4))\nplot(collect(1:k_dim), bandstructure_par, \"k--\")\nplot(collect(1:k_dim), bandstructure_perp, color=\"gold\")\nxticks(positions, labels)\nylim([-5.2, 5.2])\n\ntight_layout()\nsavefig(\"band_structure_2D.svg\") # hide","category":"page"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"(Image: )","category":"page"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"The next example shows how one can compute the decay rates for a 2 square lattices with atoms polarized in-plane (y-axis) and perpendicularly (x-axis). This can be found in A. Asenjo-Garcia et al, 10.1103/PhysRevX.7.031024 (Figs. 2c and 2d).","category":"page"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"polarization_par = [0, 1, 0]\npolarization_perp = [1, 0, 0]\na_vec1 = [0.2, 0]\na_vec2 = [0, 0.2]\nk_max = 200\n\nk_list = [iii*pi/(a_vec1[1]*k_max) for iii=-k_max:k_max]\nk_dim = length(k_list)\ndecay_par = zeros(k_dim, k_dim)\ndecay_perp = zeros(k_dim, k_dim)\ny = 1\nfor ky in k_list\n    z = 1\n    for kz in k_list\n        k = [ky, kz]\n        decay_par[z, y] = Gamma_k_2D(k, a_vec1, a_vec2, polarization_par)\n        decay_perp[z, y] = Gamma_k_2D(k, a_vec1, a_vec2, polarization_perp)\n        z += 1\n    end\n    global y += 1\nend\n\n\npositions = [0, k_max, 2*k_max]\nlabels = [-1, 0, 1]\n\nfigure(figsize=(10,4))\nsubplot(121)\nimshow(decay_par, cmap=\"jet\")\ncolorbar()\nclim(0, 22)\nxlabel(\"k_y d/pi\")\nylabel(\"k_z d/pi\")\nplt.xticks(positions, labels)\nplt.yticks(positions, labels)\n\nsubplot(122)\nimshow(decay_perp, cmap=\"jet\")\ncolorbar()\nclim(0, 22)\nxlabel(\"k_y d/pi\")\nylabel(\"k_z d/pi\")\nplt.xticks(positions, labels)\nplt.yticks(positions, labels)\n\ntight_layout()\nsavefig(\"decay_2D.svg\") # hide","category":"page"},{"location":"collective_modes/","page":"Collective Modes","title":"Collective Modes","text":"(Image: )","category":"page"}]
}
